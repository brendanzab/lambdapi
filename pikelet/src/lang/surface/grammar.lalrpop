use crate::lang::Ranged;
use crate::lang::surface::{Term, TermData, Literal, TypeEntry, TermEntry};

grammar;

match {
    r"\|\|\|[^\n\r]*[\n\r]*"        => DocComment,
    r#"'([^'\\]|\\')*'"#            => CharacterLiteral,
    r#""([^"\\]|\\")*""#            => StringLiteral,
    r"[-+]?[0-9]+(\.[0-9]+)?"       => NumericLiteral,
    r"[a-zA-Z][a-zA-Z0-9\-]*"       => Name,
    r"\^[0-9]+(\.[0-9]+)?"          => Shift,

    "as",
    "fun",
    "Fun",
    "record",
    "Record",

    "->",
    "=>",
    ":",
    "=",
    ",",
    ".",

    "{", "}",
    "[", "]",
    "(", ")",

    r"\s*" => { },                  // Skip whitespace
    r"--[^\n\r]*[\n\r]*" => { },    // Skip `-- comments`
}

pub Term: Term<&'input str> = Ranged<TermData>;
ArrowTerm: Term<&'input str> = Ranged<ArrowTermData>;
ExprTerm: Term<&'input str> = Ranged<ExprTermData>;
AppTerm: Term<&'input str> = Ranged<AppTermData>;
AtomicTerm: Term<&'input str> = Ranged<AtomicTermData>;

TermData: TermData<&'input str> = {
    ExprTermData,
    <term: ExprTerm> ":" <ty: Term> => TermData::Ann(Box::new(term), Box::new(ty)),
};

ExprTermData: TermData<&'input str> = {
    ArrowTermData,
    "fun" <input_names: Ranged<Name>+> "=>" <output_term: ExprTerm> => {
        TermData::FunctionTerm(input_names, Box::new(output_term))
    },
};

ArrowTermData: TermData<&'input str> = {
    AppTermData,
    "Fun" <input_type_groups: ("(" <Ranged<Name>+> ":" <ArrowTerm> ")")+>
        "->" <output_type: ArrowTerm> =>
    {
        TermData::FunctionType(input_type_groups, Box::new(output_type))
    },
    <input_type: AppTerm> "->" <output_type: ArrowTerm> => {
        TermData::FunctionArrowType(Box::new(input_type), Box::new(output_type))
    },
};

AppTermData: TermData<&'input str> = {
    AtomicTermData,
    <head_term: AtomicTerm> <input_terms: AtomicTerm+> => {
        TermData::FunctionElim(Box::new(head_term), input_terms)
    },
};

AtomicTermData: TermData<&'input str> = {
    "(" <term: TermData> ")" => term,
    <name: Name> => TermData::Name(name),
    <term: AtomicTerm> <shift: Shift> => {
        TermData::Lift(Box::new(term), shift[1..].parse().unwrap()) // FIXME: Overflow!
    },
    "Record" "{" <entries: List<TypeEntry>> "}" => TermData::RecordType(entries),
    "record" "{" <entries: List<TermEntry>> "}" => TermData::RecordTerm(entries),
    <head_term: AtomicTerm> "." <label: Ranged<Name>> => TermData::RecordElim(Box::new(head_term), label),
    "[" <entries: List<Term>> "]" => TermData::Sequence(entries),
    <literal: Literal> => TermData::Literal(literal),
};

List<Entry>: Vec<Entry> = {
    <mut entries: (<Entry> ",")*> <last: Entry?> => {
        entries.extend(last);
        entries
    }
}

TypeEntry: TypeEntry<&'input str> = {
    // TODO: Use doc comments
    <_docs: DocComment*>
    <label: Ranged<Name>> <name: ("as" <Ranged<Name>>)?> ":" <term: Term> => (label, name, term),
};

TermEntry: TermEntry<&'input str> = {
    // TODO: Use doc comments
    <_docs: DocComment*> <label: Ranged<Name>> "=" <term: Term> => (label, term),
};

Literal: Literal<&'input str> = {
    CharacterLiteral => Literal::Char(<>),
    StringLiteral => Literal::String(<>),
    NumericLiteral => Literal::Number(<>),
};

Ranged<T>: Ranged<T> = {
    <start: @L> <data: T> <end: @R> => Ranged::new(start..end, data),
};
